;Вариант 5
 org 100h

start:
        mov ah, 09h
        mov dx, inputA  ;просьба ввести значение А
        int 21h

        mov ah, 0ah
        mov dx, strA    ; 0aH ввод строки в буфер,где первый символ в буфере max длинна строки в второй фактическая
        int 21h         ;вводим число A

        mov bx, dx         ;помещаем в bx ссылку на строку в качестве передачи регистра как параметра процедуры(bx используется при индексированной адресации.)
        call count_number  ;извлекаем из строки число L
        push ax            ;результат из регистра ах помещаем в стек

        mov ah, 02h     ;Посылает символ из DL на стандартный вывод. обрабатывает символ Backspace (ASCII 8), перемещая курсор влево на одну позицию и оставляя его в новой позиции
        mov dx, 0x0D0A  ;A значение ASCII для символа новой строки,D 10 значение ASCII возврата каретки.
        int 21h

        mov ah, 09h
        mov dx, inputB  ;просьба ввести значение В
        int 21h

        mov ah, 0ah
        mov dx, strB   ;вводим число В
        int 21h

        mov bx, dx
        call count_number    ;извлекаем из строки число M
        push ax              ;результат из регистра ах в стек

        call get_result      ;получаем результат вычислений

        mov ax, [res]        ;перемещаем в ах результат для последующего вывода ответ
        call output_number   ;вывод ответа

        pop ax               ;очистка стека
        pop ax

        mov ah, 08h
        int 21h      ;конец главной программы
        ret






count_number:      ;процедура получения числа из строки
    xor ax, ax      ;обнуляем ах     зачем? без обнуления не работает(
    xor dx, dx      ;обнуляем dx
    add bx, 1h      ;передвигаем адрес строки на 1
    mov cl, [bx]    ;забираем 1 байт, в котором находится фактическая длина строки

lp:                ;цикл извлечения числа
    inc bx          ;увеличиваем указатель на строку на 1
    mul [cm]        ;умножаем на 10
    add al, [bx]    ;прибавляем цифру
    sub ax, '0'     ;убираем код '0'

    loop lp         ;уменьшаем регистр сх на 1, сравниваем с нулем, если не ноль, то повторяем цикл
    ret

output_number:    ;процедура вывода числа на экран
    push '*'        ;запоминаем, что концом числа в стеке будет символ *

lpt:                            ;цикл разбиения числа на цифры и передача его в стек
    div [cm]        ;деление числа на 10, остаток уходит в dx
    push dx         ;добавляем в стек остаток от деления
    xor dx, dx      ;очищаем dx от уже занесенного результата
    cmp ax, 0h      ;сравниваем результат деления с 0   ;repeat until
    jne lpt         ;если не 0, то заново цикл


    mov ah, 02h
    mov dx, 0x0D0A
    int 21h

lpp:     ;цикл вывода числа
    pop bx          ;вытаскиваем число из стека

    cmp bx, '*'     ;если конец стека        ;if
    je endst        ;то выходим из цикла

    add bx, '0'     ;иначе добавляем '0' чтобы получить символ

    mov ah, 02h
    mov dx, bx      ;выводим символ
    int 21h

    jmp lpp         ;повтор цикла

endst: ret ;выход

get_result:
        mov bp, sp      ;в регистр bp передаем указатель на стек для доступа к другим переменным стека


        ;работаем через регистры
       ; mov ax, [bp+4]  ;в регистр ах передаем переменную A
       ; mov bx, [bp+2]  ;в регистр bx передаём переменную B
       ; div bx          ;А/B в ах
      ;  mov bx, ax      ;А/В в bх

       ; mov cx, 7h
        ;mov ax, [bp+2]  ;в регистр bx передаём переменную B
       ; mul cx          ;7*B в регистр ах

       ; call proc1      ;вызов процедуры


            ;переход на новую строку
          ;  mov ah,9h
           ; mov dx, new_line
          ;  int 21h

            ;вывод текста в консоль
           ; mov ah,9h
          ;  mov dx, str3
           ; int 21h

            ;вывод в консоль результата
           ; mov ah,2h
           ; mov dx, [res]
           ; int 21h

            ;переход на новую строку
           ; mov ah,9h
           ; mov dx, new_line
           ; int 21h

                ;ожидание нажатия клавиши
              ;  mov ah, 8h
               ; int 21h



        ;работаем через глобальные переменные
       ; mov ax, [bp+4]
       ; mov bx, [bp+2]
       ;div bx
       ; mov [A], ax

       ; mov ax, 7h
       ; mov cx, [bp+2]  ;в регистр bx передаём переменную B
       ; mul cx          ;7*B в регистр ах
       ; mov [B], ax

       ; call proc2 ;вызов процедуры

                ;переход на новую строку
              ;  mov ah,9h
               ; mov dx, new_line
              ;  int 21h

                ;вывод текста в консоль
              ;  mov ah,9h
              ;  mov dx, str4
               ; int 21h

                ;вывод в консоль результата
              ;  mov ah,2h
               ; mov dx, [res]
               ; int 21h

                ;переход на новую строку
               ; mov ah,9h
               ; mov dx, new_line
               ; int 21h



        ;работа через стек
        mov ax, [bp+4]
        mov bx, [bp+2]
        div bx
        mov bx, ax
        push bx

        mov ax,7h
        mov cx, [bp+2]
        mul cx
        mov cx, ax
        push cx

        call proc3

                ;переход на новую строку
                mov ah,9h
                mov dx, new_line
                int 21h

                ;вывод текста в консоль
                mov ah,9h
                mov dx, str5
                int 21h

                ;вывод в консоль результата
                mov ah,2h
                mov dx, bx
                int 21h

                ;переход на новую строку
                mov ah,9h
                mov dx, new_line
                int 21h

                ;ожидание нажатия клавиши
                mov ah, 8h
                int 21h

        ret  ;выходим из процедуры


proc1:
    sub bx, ax ;разность
    add bx, '0' ;перевод в ASCII (ноль это 48 номер в таблице)
    mov [res], bx   ;сохраняем результат
    ret

proc2:
    mov bx, [A]  ; извлекаем параметр A
    mov cx, [B]  ; извлекаем параметр B
    sub bx, cx  ;разность
    add bx, '0'  ;перевод в ASCII код
    mov [res], bx  ; сохраняем значение в памяти
    ret

proc3:
    pop dx  ; извлекаем адрес возврата к основной программе
    pop cx ; извлекаем параметр B
    pop bx ; извлекаем параметр A
    sub bx,cx ;разность
    add bx, '0' ;перевод в ASCII код
    ;mov [res], bx  ; сохраняем значение в памяти
    push dx ; возвращаем на место адрес возврата к основной программе
    ret





inputA          db "Enter number A: $"
inputB          db "Enter number B: $"
str3            db "Register procedure result is $"
str4            db "Memory procedure result is $"
str5            db "Stack procedure result is $"
strA            db 10, 0, 10 dup(?)
strB            db 10, 0, 10 dup(?)
numA            dw 0h
numB            dw 0h
new_line        db $0d, $0A, "$"
cm              dw 10
A               dw 0h
B               dw 0h
res             dw 0h